<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modification maquette</title>

    <link href="assets/css/handsontable.full.min.css" rel="stylesheet">

    <script src="assets/js/handsontable.full.min.js"></script>
    <script src="assets/js/d3.min.js"></script>
    <style>

        td {
            vertical-align: top;
        }
        .rGrid {
            height:200px;
            overflow: scroll;
        }
        .grid {
            height:300px;
            width:300px;
        }
    </style>
</head>
<body>
    <table border="1" style="width: 100%;">
        <tr>
            <th>Maquette</th>
            <th>Compétences</th>
        </tr>
        <tr>
            <td >
                <div>
                    <label for="fileMaquette" class="btn">Charger le maquette</label>
                    <input type="file" id="fileMaquette" accept=".csv" >
                    <button id="exportgridMaquette">Exporter</button>
                </div>
                <div id="gridMaquette" class="grid"></div>
            </td>
            <td >
                <div>
                    <label for="fileBlocComp" class="btn">Charger les blocs de compétences</label>
                    <input type="file" id="fileBlocComp" accept=".csv" >
                    <button id="exportgridBlocComp">Exporter</button>
                </div>
                <div id="gridBlocComp"  class="grid"></div>
            </td>
        </tr>
        <tr>
            <td>
                <button id="setEcComp">Récupérer les compétences ROME des EC</button>
                <button id="exportFileCompMaquette">Exporter les compétences de la maquette</button>
                <div>
                    <label for="fileCompMaquette" class="btn">Charger les compétences de la maquette</label>
                    <input type="file" id="fileCompMaquette" accept=".json" >
                </div>
                <div class="rGrid">
                    <ul id="ecComp">
                    </ul>    
                </div>

            </td>
            <td >
                <table border="1">
                    <tr id="blocsTitre">
                    </tr>
                </table>                           
                <button id="getBlocComp">Récupérer les compétences ROME des blocs RNCP</button>
                <!--<button id="getBlocCompRome">Voir les compétences ROME</button>!-->
                <button id="exportFileCompBloc">Exporter les compétences des blocs</button>
                <div>
                    <label for="fileCompBlocComp" class="btn">Charger les compétences des blocs</label>
                    <input type="file" id="fileCompBlocComp" accept=".json" >
                </div>
                <div class="rGrid">
                    <ul id="blocComp">
                    </ul>
                </div>
            </td>
        </tr>
        <tr>
            <td>
                <button id="setEcPoidsBlocComp">Calculer le poids des Bloc de compétences</button>
                <button id="exportgridRepatitionECTS">Exporter</button>
                <div id="gridRepatitionECTS" class="grid"></div>
            </td>
            <td>
                <button id="setMatriceFormation">Calculer la matrice de la formation</button>
                <button id="exportgridMatriceFormation">Exporter le tableau</button>
                <button id="exportMatriceFormation">Exporter la matrice</button>
                <div>
                    <label for="fileMatriceFormation" class="btn">Charger la matrice</label>
                    <input type="file" id="fileMatriceFormation" accept=".json" >
                </div>
                <div id="gridMatriceFormation" class="grid"></div>
            </td>
        </tr>
        <tr>
            <td colspan="2">
                <button id="setProfilApprenant">Calculer le profil de l'apprenant</button>
                <button id="exportgridProfilApprenant">Exporter le tableau</button>
                <button id="exportProfilApprenant">Exporter le profil</button>
                <div>
                    <label for="fileProfilApprenant" class="btn">Charger le profil</label>
                    <input type="file" id="fileProfilApprenant" accept=".json" >
                </div>
                <div id="gridProfilApprenant" class="grid"></div>
            </td>
        </tr>
    </table>
    
    <script type="module">
        import {auth} from './modules/auth.js';
        import {semafor} from './modules/semafor.js';
        import {francetravail} from './modules/francetravail.js';

        let a = new auth({
            mail:'acehn@univ-paris8.fr',
            apiOmk:'http://localhost/omk_gestForma/api/',
            //apiOmk:'https://acehn.jardindesconnaissances.fr/api',
            ident: 'Fe82ZlMwNP8KR88BKWzGNnF7eS5qChwr',
            key:'Jo5RZc9S3qr79GAe2TZk9UBakWcZbP48',
        }),
        sema = new semafor({'omk':a.omk}),
        ft = new francetravail(),
        ficheRNCP, blocsRNCP=[], itemsBloc=[], blocSelect, thBlocs, colorBase="#0080003d", colorSelect="#80002d3d",
        ecsMaq, finCharge=true, renforcePoidsEc=1, renforcePoidsBloc=2, renforcePoidsPositif=2,
        headers = ["parcours","code","LIB","ECTS","verifECTS",
            "BlocComp1","BlocComp2","BlocComp3","BlocComp4","BlocComp5","BlocComp6","BlocComp7","BlocComp8",
            "BlocComp1poids","BlocComp2poids","BlocComp3poids","BlocComp4poids","BlocComp5poids","BlocComp6poids","BlocComp7poids","BlocComp8poids"],
        compDetails=[],poidsDetails=[],metiersDetails=[],profilApprenant=[];

        /*chargement automatique des exemples
        Promise.all([d3.csv("assets/data/BlocsCompetencesHN.csv"),d3.csv("assets/data/EcACEHN.csv")]).then(values => {
            ecsMaq = values[1];
            blocsRNCP = values[0];
            showGrid("gridMaquette",values[1]);
            showGrid("gridBlocComp",values[0]);
            finCharge = true;
        });
        */
            
        document.querySelector('#fileMaquette').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const contents = e.target.result;
                    ecsMaq = d3.csvParse(contents);
                    showGrid("gridMaquette",ecsMaq);
                };
                reader.readAsText(file);
            }
        });
        document.querySelector('#fileBlocComp').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const contents = e.target.result;
                    blocsRNCP = d3.csvParse(contents);
                    showGrid("gridBlocComp",blocsRNCP);
                };
                reader.readAsText(file);
            }
        });

        document.querySelector('#fileCompBlocComp').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const contents = e.target.result;
                    blocsRNCP = JSON.parse(contents);
                    showGrid("gridBlocComp",blocsRNCP);
                    getSemaBlocCompRome();
                };
                reader.readAsText(file);
            }
        });                

        document.querySelector('#fileCompMaquette').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const contents = e.target.result;
                    ecsMaq = JSON.parse(contents);
                    showGrid("gridMaquette",ecsMaq);
                    getSemaECRomeComp();
                };
                reader.readAsText(file);
            }
        });                                

        document.querySelector('#getBlocComp').addEventListener('click', () => {
            if (!finCharge) {
                alert('Veuillez attendre le chargement des données.');
                return;
            }
            getSemaBlocCompRome();
        });
        document.querySelector('#setEcComp').addEventListener('click', () => {
            if (!finCharge) {
                alert('Veuillez calculer les données pour la maquette et les blocs.');
                return;
            }
            getSemaECRomeComp();
        });  
        document.querySelector('#setEcPoidsBlocComp').addEventListener('click', () => {
            if (ecsMaq.length==0 || blocsRNCP.length==0) {
                alert('Veuillez attendre le chargement des données.');
                return;
            }
            showRepartitionComp();
        });
        document.querySelector('#setMatriceFormation').addEventListener('click', () => {
            if (ecsMaq.length==0 || blocsRNCP.length==0) {
                alert('Veuillez attendre le chargement des données.');
                return;
            }
            calculMatriceFormation();
        });
        
        document.querySelector('#fileMatriceFormation').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const contents = JSON.parse(e.target.result);
                    blocsRNCP = contents.blocsRNCP;
                    showGrid("gridBlocComp",blocsRNCP);
                    getSemaBlocCompRome();
                    ecsMaq = contents.ecsMaq;
                    showGrid("gridMaquette",ecsMaq);
                    getSemaECRomeComp();
                    poidsDetails = contents.poidsDetails;
                    compDetails =  contents.compDetails;              
                    showMatriceFormation();
                };
                reader.readAsText(file);
            }
        });        

        document.querySelector('#setProfilApprenant').addEventListener('click', () => {
            if (ecsMaq.length==0 || blocsRNCP.length==0  || poidsDetails.length==0 ) {
                alert('Veuillez charger les données nécessaires.');
                return;
            }
            metiersDetails = [];
            getMetierFromComp();
        });
        
        document.querySelector('#fileProfilApprenant').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const contents = JSON.parse(e.target.result);
                    blocsRNCP = contents.blocsRNCP;
                    showGrid("gridBlocComp",blocsRNCP);
                    getSemaBlocCompRome();
                    ecsMaq = contents.ecsMaq;
                    showGrid("gridMaquette",ecsMaq);
                    getSemaECRomeComp();
                    poidsDetails = contents.poidsDetails;
                    compDetails =  contents.compDetails;              
                    showMatriceFormation();
                    metiersDetails =  contents.metiersDetails;              
                    calculProfilApprenant();
                };
                reader.readAsText(file);
            }
        });  
        
        /*  
        document.querySelector('#getBlocCompRome').addEventListener('click', () => {
            if (!blocSelect) {
                alert('Veuillez choisir un bloc de compétence.');
                return;
            }
            getBlocCompRome();
        });  
        //pour le calcule automatique après sauvegarde des objets ecsMaq et itemsBloc
        Promise.all([d3.json("assets/refs/blocComp.json"),d3.json("assets/refs/ecsMaqComp.json")]).then(values => {
            ecsMaq=values[1];
            itemsBloc=values[0];
            //ajoute les colonnes de bloc compétences
            let libBloc = {"parcours":"parcours","code":"code","LIB":"LIB","ECTS":"ECTS","verifECTS":"verifECTS",
                "BlocComp1":"no","BlocComp2":"no","BlocComp3":"no","BlocComp4":"no","BlocComp5":"no","BlocComp6":"no","BlocComp7":"no","BlocComp8":"no",
                "BlocComp1poids":0,"BlocComp2poids":0,"BlocComp3poids":0,"BlocComp4poids":0,"BlocComp5poids":0,"BlocComp6poids":0,"BlocComp7poids":0,"BlocComp8poids":0
                };
            itemsBloc.forEach((b,i)=>{
                libBloc["BlocComp"+(i+1)]=b["o:title"];
                libBloc["BlocComp"+(i+1)+"poids"]=b["o:id"];
            })  
            ecsMaq.forEach((e,j)=>{
                calculNbEcts(e);
                e.verifECTS = 0;
                e.blocEcts.forEach((bloc,i)=>{
                    e["BlocComp"+bloc.bloc]= bloc.ects;
                    e["BlocComp"+bloc.bloc+"poids"]= bloc.poids;
                    e.verifECTS += bloc.ects;
                })
                e.verifECTS -= e["ECTS"];
            })
            
            //calcul 
            ecsMaq.push(libBloc)
            showMaquette(headers, ecsMaq);                
        })
        */

        /*Pour la récupération des compétences via semafor  
        d3.csv("assets/refs/listeEC-HNsimple.csv").then(maq=>{
            //format les données        
            ecsMaq = maq.map(ec=>{
                    let e = {};
                    headers.forEach(h=>e[h]=ec[h]);
                    return e;
                });
            showMaquette(headers, ecsMaq);                
        });
        //récupère ls blocs de compétence
        d3.json(a.apiOmk+"items/78933").then(data=>{
            ficheRNCP = data;
            thBlocs = d3.select("#blocsTitre").selectAll("th").data(ficheRNCP["rncp:hasBLOC_COMPETENCES"]).enter().append("th")
                .style("cursor","zoom-in")
                .style("background-color",colorBase)
                .attr("id",d=>"blocComp"+d.value_resource_id)
                .on("click",voirCompBloc).text(d=>d.display_title);
            ficheRNCP["rncp:hasBLOC_COMPETENCES"].forEach(d=>document.getElementById("blocComp"+d.value_resource_id).click());
        });
        */

        function voirCompBloc(e,d){
            thBlocs.style("background-color",colorBase);
            d3.select(e.currentTarget).style("background-color",colorSelect);
            if(!itemsBloc[d.value_resource_id]){
                itemsBloc[d.value_resource_id]=a.omk.getItem(d.value_resource_id);
            }
            blocSelect=itemsBloc[d.value_resource_id];            
            let ulBlocsComp = d3.select("#blocsComp");
            ulBlocsComp.selectAll("li").remove()
            let ulBlocComp = ulBlocsComp.selectAll("li").data(itemsBloc[d.value_resource_id]["rncp:LISTE_COMPETENCES"]).enter().append("li")
                .text(d=>d["@value"] ? d["@value"] : d.display_title)
                .style("background-color",d=>d["@value"] ? colorBase : colorSelect)
                .append("ul")
                    .attr("id",(d,i)=>d.value_resource_id ? "rncpcomp"+d.value_resource_id : "rncpcomp"+i);
            getBlocCompRome();
        }

        function getBlocCompRome(){
            blocSelect["rncp:LISTE_COMPETENCES"].forEach(c=>{
                if(c.value_resource_id){
                    let oComp = a.omk.getItem(c.value_resource_id),
                    ulCompRcnp = d3.select("#rncpcomp"+oComp["o:id"]);
                    ulCompRcnp.selectAll("li").remove();
                    ulCompRcnp.selectAll("li").data(oComp["rome:hasCompetence"]).enter().append("li")
                        .html(d=>{
                            return "<b>"+d["@annotation"]["rome:similarity"][0]["@value"]+"</b> "+d.display_title;
                        })
                    if(!blocSelect['romeComp'])blocSelect['romeComp']=[];
                    blocSelect['romeComp'].push(oComp);
                }
            })
        } 

        async function getSemaComp(i=0){
            //vérifie si les compétences du bloc sont décomposée
            let c = blocSelect["rncp:LISTE_COMPETENCES"][i];
            if(!c.value_resource_id){
                console.log(c["@value"]);
                let comp = await sema.search("Competences",c["@value"]),
                    code = blocSelect["rncp:CODE"][0]["@value"]+'_comp'+i,
                    dt = {'rt':'RNCP élément','c':'rncp:COMPETENCE',
                        'dt':{'rncp:CODE':code,
                            'rncp:LIBELLE':c["@value"],
                        },
                        'verif':{'rncp:LIBELLE':c["@value"]},
                        'index':code
                    },
                    omkComp = await a.omk.getsetResource(dt);
                    console.log(omkComp);
                //met à jour le bloc de compétence
                a.omk.updateRessource(blocSelect["o:id"], {"rncp:LISTE_COMPETENCES":{'rid':omkComp['o:id']}}, 'items', null, 'PUT',showFindComp,blocSelect);
                //met à jour les similarités avec ROME
                sema.setFind(omkComp,comp,showFindComp);
            }
            if(i<blocSelect["rncp:LISTE_COMPETENCES"].length-1){
                setTimeout(() => {
                    getSemaComp(i+1);
                }, 1000);
            }
        }

        async function showSemaECRomeComp(code,lib){
            let ec = ecsMaq.filter(e=>e.code==code)[0];
            //récupère les compétences pour l'EC 
            ec.semaFind = ec.semaFind ? ec.semaFind : await sema.search("Competences",lib);
            //ajoute l'EC
            d3.select("#ecComp").select('#ec'+code).remove();
            let ulEc = d3.select("#ecComp").append("li").attr('id','ec'+code).html("<b>"+code+"</b> "+lib)
                .append("ul"); 
            ulEc.selectAll('li').data( ec.semaFind.search_results).enter().append("li")
                .attr('id',(d,i)=>code+'sema'+d.data.code_ogr)
                .html(d=>{
                    return "<b>"+d.similarity+"</b> "+d.text;
                });
            //recalcul les poids
            calculNbEcts(ec);
            //affiche le détails par compétence d'EC
            let cpEcComp = d3.group(ec.poidsDetails, d => d.code, d => d.idBloc);
            cpEcComp.forEach((ecComp,code_ogr) => {
                let idUl = code+'sema'+code_ogr,
                    ul = d3.select('#'+idUl).append("ul");
                ul.selectAll('li').data(ecComp).enter().append("li").html(d=>{
                    return "<b>"+d3.sum(d[1], s=>s.simBloc)+"</b> Bloc "+d[1][0].idBloc;//+" : "+d[0];
                });
            });             

        }


        async function showSemaBlocRomeComp(code,lib){
            let bloc = blocsRNCP.filter(e=>e.code==code)[0];
            //récupère les compétences pour l'EC 
            bloc.semaFind = bloc.semaFind ? bloc.semaFind : await sema.search("Competences",lib);
            //ajoute l'EC
            d3.select("#blocComp").select('#bloc'+code).remove();
            let ulEc = d3.select("#blocComp").append("li").attr('id','bloc'+code).html("<b>"+code+"</b> "+lib)
                .append("ul"); 
            ulEc.selectAll('li').data( bloc.semaFind.search_results).enter().append("li")
                .attr('id',(d,i)=>'sema'+i)
                .html(d=>{
                    return "<b>"+d.similarity+"</b> "+d.text;
                });
        }

        function calculSimilariteBlocEc(ec){
            //calcul la similarité avec les blocs
            let poidsDetails = [];
            /*version OMK
            itemsBloc.forEach((ib,i)=>{
                let cp = calculePoids(ib,ec);
                cp.details.forEach(d=>d.numBloc=i+1);
                poidsDetails = poidsDetails.concat(cp.details);
            })
            */
            blocsRNCP.forEach((ib,i)=>{
                let cp = calculePoids(ib,ec);
                cp.details.forEach(d=>d.numBloc=i+1);
                poidsDetails = poidsDetails.concat(cp.details);
            })
            return poidsDetails;
        }

        function renforcePoids(s){
            return (
                (s.simBloc > 0 ? s.simBloc*renforcePoidsPositif : s.simBloc)
                    *renforcePoidsBloc)
                +(
                    (s.simEc > 0 ? s.simEc*renforcePoidsPositif : s.simEc)
                    *renforcePoidsEc
                );            
        }

        function calculNbEcts(ecs){
            //calcul l'échelle des blocs
            ecs.poidsDetails = calculSimilariteBlocEc(ecs);
            let ECTS = parseInt(ecs.ECTS),
                blocPoids = d3.flatGroup(ecs.poidsDetails, d => d.numBloc).map(b => {
                    return {
                        'poids':d3.sum(b[1], s=>renforcePoids(s)),
                        'poidsBloc':d3.sum(b[1], s=>s.simBloc),
                        'poidsEc':d3.sum(b[1], s=>s.simEc),
                        'nbEc':b[1].length,
                        'bloc':b[0]
                    };
                }),
                extPoids = d3.extent(blocPoids.map(bp=>bp.poids)),
                rangePoids = [0,ECTS],//d3.range(1,ECTS+1),//.map(r=>r+""),[1,ECTS],// 
                //scalePoids = d3.scaleBand(rangePoids, extPoids),
                //scalePoids = d3.scaleOrdinal(extPoids,rangePoids),
                //
                scalePoids = d3.scaleLinear(extPoids,[0,1]),
                scaleEcts = d3.scaleLinear(rangePoids),                
                /*
                T = scalePoids.ticks(10),
                f = scalePoids.tickFormat(10,"%"),
                leg = T.map(f),
                */
                ecBlocPoids = d3.flatGroup(ecs.poidsDetails, d => d.numBloc).map(b => {
                    let c = {'bloc':b[0],'idBloc':b[1][0].idBloc,'poids':d3.sum(b[1], s=>s.simBloc+(s.simEc*2))};
                    c.poidsEcts = scalePoids(c.poids);
                    c.numEcts = scaleEcts(c.poidsEcts);//f(c.poids);
                    c.ects = 0;
                    return c;
                });
            if(ecBlocPoids.length){
                let reste = ECTS;
                while (reste >= 1) {
                    //ordonne le résultat pour prendre le plus grand 
                    ecBlocPoids = ecBlocPoids.sort((a, b) => b.numEcts - a.numEcts);
                    ecBlocPoids[0].ects += 1;
                    ecBlocPoids[0].numEcts -= 1;
                    reste -= 1;
                }
            }
            //attribut les ects
            console.log(ecBlocPoids);            
            ecs.blocEcts = ecBlocPoids;
            return ecBlocPoids;
        }

        function calculePoids(bloc,ec){
            let poids = 0, details=[];
            /*version OMK
            bloc.romeComp.forEach(rc=>{
                rc["rome:hasCompetence"].forEach(hc=>{
                    let romeComp = hc,
                        sim =  parseFloat(hc["@annotation"]["rome:similarity"][0]["@value"]),
                        code = hc["@annotation"]["rome:codeOgr"][0]["@value"];
                    ec.semaFind.search_results.forEach((sr,i)=>{
                        let result = "";
                        if(sr.data.code_ogr==code){
                            details.push({'idBloc':rc["o:id"],'titreBloc':rc["o:title"],'i':i,'type':sr.data.item_type,'code':code,'titre':sr.data.titre,'simBloc':sim,'simEc':parseFloat(sr.similarity)})
                            poids+=sim+parseFloat(sr.similarity);
                        }
                    })
                })
            })
            */
            bloc.semaFind.search_results.forEach((rc,j)=>{
                let sim =  rc.similarity,
                    code = rc.data.code_ogr;
                ec.semaFind.search_results.forEach((sr,i)=>{
                    let result = "";
                    if(sr.data.code_ogr==code){
                        details.push({'idBloc':bloc.code.split('-')[0],'idCompAsso':bloc.code,'Bloc de Compétence':bloc["Bloc de Compétence"],'Compétence associées':bloc["Compétence associées"],'i':i,'type':sr.data.item_type,'code':code,'titre':sr.data.titre,'simBloc':sim,'simEc':parseFloat(sr.similarity)})
                        poids+=sim+parseFloat(sr.similarity);
                    }
                })
            })

            return {"poids":poids,"details":details};
        }

        async function calculePoidsBlocComp(){
            console.log('test');
        }

        async function getSemaECRomeComp(row=0){
            console.log(row+" : "+ecsMaq[row].EC);
            ecsMaq[row].semaFind = ecsMaq[row].semaFind ? ecsMaq[row].semaFind : await sema.search("Competences",ecsMaq[row].UE+" "+ecsMaq[row].EC,20);
            await showSemaECRomeComp(ecsMaq[row].code,ecsMaq[row].EC)
            if(row < ecsMaq.length-1)getSemaECRomeComp(row+1);
        }

        async function getSemaBlocCompRome(row=0){
            console.log(row+" : "+blocsRNCP[row]["Compétence associées"]);
            blocsRNCP[row].semaFind = blocsRNCP[row].semaFind ? blocsRNCP[row].semaFind 
                : await sema.search("Competences",blocsRNCP[row]["Bloc de Compétence"]+" "+blocsRNCP[row]["Compétence associées"],20);
                //: await sema.search("Competences",blocsRNCP[row]["Compétence associées"]);
            await showSemaBlocRomeComp(blocsRNCP[row].code,blocsRNCP[row]["Compétence associées"])
            if(row < blocsRNCP.length-1)getSemaBlocCompRome(row+1);
        }        

        function showRepartitionComp(){
            /*
            Blocs de compétences de la fiche n°38207	Intitulé des compétences associées au  bloc de compétences 	Intitulé des compétences associées au bloc de compétences définis par l'équipe pédagogique	" Objectifs d'apprentissage visés
(Contributions à l'acquisition des compétences)"	"UE
(n° et intitulé)"	"EC 
(n° et intitulé)"	Critères et modalités d'évaluation	ECTS	HCM	HTD
            */
            //ajoute les colonnes de bloc compétences
            let rs = [], rsBloc = d3.group(blocsRNCP, d => d.code.split("-")[0]);            
            ecsMaq.forEach((e,j)=>{
                let r = JSON.parse(JSON.stringify(e));
                r["ECTS"] = parseInt(r["ECTS"]);
                r.verifECTS=0;
                delete r["blocEcts"];
                delete r["semaFind"];
                delete r["poidsDetails"];
                rsBloc.forEach((b,i) => {
                    r[i]=0;
                    //r[i+" poids"]=0;
                    
                })
                e.blocEcts.forEach((bloc,i)=>{
                    r[bloc.idBloc]= bloc.ects;
                    //r[bloc.idBloc+" poids"]= bloc.poids;
                    r.verifECTS += bloc.ects;
                })
                r.verifECTS -= r["ECTS"];
                rs.push(r);
            })
            
            showGrid("gridRepatitionECTS", rs);
        }

        function showMatriceFormation(){
            console.log(compDetails);
            console.log(poidsDetails);
            let headers = ["Blocs de compétences","Intitulé des compétences associées","Intitulé des compétences définis par l'équipe pédagogique","Objectifs d'apprentissage","UE","EC","Critères et modalités d'évaluation","ECTS","HCM","HTD"],
                rs = [], rsBloc = d3.group(blocsRNCP, d => d.code.split("-")[0]);
            rsBloc.forEach((b,i) => {
                let l1 = true;
                b.forEach((bloc,j)=>{
                    //récupère les compétences ROME pour les compétences associées RCNP
                    let filterComp = poidsDetails.filter(pd=>pd.idCompAsso==bloc.code);
                    filterComp.forEach((comp,j)=>{
                        let r = {};
                        headers.forEach(h=>r[h]=" ");
                        if(l1)r["Blocs de compétences"] = bloc["Bloc de Compétence"];
                        if(j==0)r["Intitulé des compétences associées"] = bloc["Compétence associées"];
                        r["Intitulé des compétences définis par l'équipe pédagogique"] = comp.compTitre;
                        //récupère la compétence détaillée
                        let cd = compDetails.filter(cd=>cd.code==comp.compCode)[0];
                        if(cd.macroCompetence)
                            r["Objectifs d'apprentissage"] = cd.macroCompetence.objectif.libelle;                        
                        else
                            r["Objectifs d'apprentissage"] = cd.objectif.libelle;
                        //récupère les détails de l'EC
                        let ec = ecsMaq.filter(ec=>ec.EC==comp.EC)[0];
                        r.UE = ec.UE;
                        r.EC = ec.EC;
                        r["Critères et modalités d'évaluation"] = "projet";
                        r.ECTS = ec.ECTS
                        r.HCM = 30;
                        r.HTD = 30;
                        rs.push(r);
                        l1 = false;
                    })
                })
            })
            showGrid("gridMatriceFormation", rs);
        }
        
        function calculMatriceFormation(){

            //applatie les données
            let oComp={};
            poidsDetails=[];            
            ecsMaq.forEach((e,j)=>{
                e.poidsDetails.forEach(poids=>{
                    let r = {'EC':e.EC};
                    r.idCompAsso = poids.idCompAsso;
                    r.compCode = poids.code;
                    r.compTitre = poids.titre;
                    oComp[poids.code] = poids.titre;
                    poidsDetails.push(r);
                })
            })
            compDetails = Object.keys(oComp);
            //récupère le détail des compétences
            getAllCompDetails();

        }        

        async function getAllCompDetails(row=0){
            console.log(row+" : "+compDetails[row]);
            compDetails[row] = await ft.search("competence",compDetails[row]);
            if(row < compDetails.length-1)getAllCompDetails(row+1)
            else showMatriceFormation();
        }

        async function getMetierFromComp(row=0){

            //récupère les métiers associés aux compétences de la matrice
            console.log(row+" : "+compDetails[row]);
            metiersDetails.push(await ft.search("appellation",compDetails[row].libelle));
            if(row < compDetails.length-1)getMetierFromComp(row+1);
            else {
                //regroupe les métiers
                let flatMetiers = [];
                metiersDetails.forEach((m,i)=>{
                    m.resultats.forEach((r,j)=>{
                        flatMetiers.push({'code':r.code,'compCode':compDetails[i].code});
                    })
                })
                metiersDetails = Array.from(d3.group(flatMetiers, d => d.code)).map(m=>{return {'code':m[0],'comp':m[1].map(c=>c.compCode)}});
                console.log(metiersDetails);
                getDetailsMetier();
            }
        }        

        async function getDetailsMetier(row=0){
            //récupère les métiers associés aux compétences de la matrice
            console.log(row+" : "+metiersDetails[row]);
            metiersDetails[row].details = metiersDetails[row].details ? metiersDetails[row].details : await ft.get("appellation",metiersDetails[row].code);
            if(row < metiersDetails.length-1)getDetailsMetier(row+1);
            else getOffresMetiers();
        }        

        async function getOffresMetiers(row=0){
            //récupère les métiers associés aux compétences de la matrice
            console.log(row+" : "+metiersDetails[row]);
            //recherche les offre pour l'appellation et le niveau niveauFormation Bac+3, Bac+4 ou équivalents =NV2
            metiersDetails[row].offres = metiersDetails[row].offres ? metiersDetails[row].offres : await ft.search("offres","appellation="+metiersDetails[row].code+"&niveauFormation=NV2");
            if(row < metiersDetails.length-1)getOffresMetiers(row+1);
            else calculProfilApprenant();
        }        

        function calculProfilApprenant(){
            let offres = [], dbOffres=[], comp=[], offresMaquette=[],
                headers = ["Fiches Rome","Métier(s)","Missions","Activités","Compétences"],
                exigence = {"E":"exigée","S":"souhaitée"};
            //met à plat les offres
            metiersDetails.forEach(m=>{
                if(m.offres.resultats)
                    m.offres.resultats.forEach(r=>{
                        if(!dbOffres[r.id]){
                            dbOffres[r.id] = r;
                            offres.push(r);
                        }
                    });   
            });
            //récupère les offres en lien avec les compétences de la maquette
            offres.forEach(o=>{
                if(o.competences){
                    o.competences.forEach(c=>{
                        if(c.code){
                            let cm = compDetails.filter(cd=>cd.code==c.code);
                            if(cm.length)offresMaquette.push({'o':o,'c':cm[0]});
                        }                    
                    });
                }
            });
            //récupère les offres regroupées par métiers
            let mao = d3.group(offresMaquette, om=> om.o.romeCode, om=>om.o.codeNAF, om => om.o.id);
            mao.forEach(omm=>{
                let r1=true;
                omm.forEach(app=>{
                    let m1=true;
                    app.forEach(om=>{
                        let o1=true;
                        om.forEach(o=>{
                            o.competences.forEach(c=>{
                                let pa = {};
                                headers.forEach(h=>pa[h]="");
                                if(r1){
                                    pa["Fiches Rome"] = om.o.romeCode+" "+om.o.romeLibelle;
                                    r1=false;
                                }
                                if(m1){
                                    pa["Métier(s)"] = om.o["intitule"]+" "+om.o.id;
                                    m1=false;
                                    pa["Missions"]=om.o.description;
                                    pa["Activités"]=om.o.qualitesProfessionnelles ? om.o.qualitesProfessionnelles.map(qp=>qp.libelle).join(", ") : " ";
                                }
                                pa["Compétences"]=c.code+" "+c.libelle+" "+exigence["c.exigence"];                        
                                profilApprenant.push(pa);
                            })
                        })    
                    })
                })    
            })
            showGrid("gridProfilApprenant", profilApprenant);
        }

        function showFindComp(data){
            console.log(data);
        }

        function showGrid(idCont, rows){
            let headers = Object.keys(rows[0]), 
                hotCours = new Handsontable(d3.select('#'+idCont).node(), {
                className: 'htDark',
                afterGetColHeader: function(col, TH){
                    TH.className = 'darkTH'
                },
                colHeaders: true,
                rowHeaders: true,
                data:rows,
                colHeaders: headers,
                height: '400px',
                autoWrapRow: true,
                autoWrapCol: true,
                manualColumnResize: true,
                width:'100%',
                stretchH: 'last',
                licenseKey: 'non-commercial-and-evaluation',
                customBorders: true,
                dropdownMenu: true,
                multiColumnSorting: true,
                filters: true,
                columns: getCellEditor(headers),
                allowInsertColumn: false,
                copyPaste: false,
                search: true,
                selectionMode: 'single', // 'single', 'range' or 'multiple',
                afterSelection: (row, column, row2, column2, preventScrolling, selectionLayerLevel) => {
                    let lib = hotCours.getDataAtCell(row,2),
                        code = hotCours.getDataAtCell(row,1);
                    console.log(code+" : "+lib);
                    showSemaECRomeComp(code,lib);
                    preventScrolling.value = true;
                }                        
            });
            const exportPlugin = hotCours.getPlugin('exportFile');
            document.querySelector('#export'+idCont).addEventListener('click', () => {
                exportPlugin.downloadFile('csv', {
                    bom: false,
                    columnDelimiter: ',',
                    columnHeaders: true,
                    exportHiddenColumns: true,
                    exportHiddenRows: true,
                    fileExtension: 'csv',
                    filename: idCont+'_[YYYY]-[MM]-[DD]',
                    mimeType: 'text/csv',
                    rowDelimiter: '\r\n',
                    rowHeaders: true,
                });
            });   
        }        

        function getCellEditor(cols){
            let editors = [];
            cols.forEach((h,i)=>{
                switch (h) {
                    case 'choix':
                        editors.push({data:h, type: 'checkbox'})                          
                        break;
                    case 'code':
                        editors.push({data:h, readOnly: true})                  
                        break;                    
                    case 'date':
                        editors.push({data:h, type:'date'})                  
                        break;                    
                    default:
                        /*
                        if(h.substring(0, 4)=="cor-")editors.push({data:h, type: 'text'}) 
                        else editors.push({data:h, readOnly: true})
                        */                 
                        if(i<=3)editors.push({data:h, type: 'text'}); 
                        else editors.push({data:h, type: 'numeric'});
                        break;
                }
            })
            return editors;
        }

        document.querySelector('#exportFileCompMaquette').addEventListener('click', () => {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(ecsMaq));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "ecMaq.json");
            document.body.appendChild(downloadAnchorNode); // required for firefox
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        })

        d3.select('#exportFileCompBloc').on('click', () => {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(blocsRNCP));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "blocsRNCP.json");
            document.body.appendChild(downloadAnchorNode); // required for firefox
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        })

        d3.select('#exportMatriceFormation').on('click', () => {
            let data = {'compDetails':compDetails,'blocsRNCP':blocsRNCP,'ecsMaq':ecsMaq,'poidsDetails':poidsDetails};
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "matriceFormation.json");
            document.body.appendChild(downloadAnchorNode); // required for firefox
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        })

        d3.select('#exportProfilApprenant').on('click', () => {
            let data = {'compDetails':compDetails,'blocsRNCP':blocsRNCP,'ecsMaq':ecsMaq,'poidsDetails':poidsDetails,'metiersDetails':metiersDetails,'profilApprenant':profilApprenant};
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "profilApprenant.json");
            document.body.appendChild(downloadAnchorNode); // required for firefox
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        })
        

    </script>

</body>
</html>
